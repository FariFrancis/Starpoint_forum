Ok for this assignment, there was just some adjustments to prior code in order to incorporate the exchange rate function. In order to do this several libraries had to be installed, this includes requests, flask_restful, Api and Resource. The only difference with my project is that I didn't have to manually install any of these as replit automatically does that when running a program. After this I set api = Api(app) which essentially just initializes the Api to work in the flask environment, which allows us to edit data and change variables in order to get an output for the API. After this I used a simple free Api to show exchange rates, specifically https://api.exchangerate-api.com/v4/latest/USD as the endpoint. Then I created an account on the website and got my api key which is used to get requests from the site, without this key there are no ways to get requests. Then I defined an api route for exchange rate and the bulk of the code happens here, get_exchange rates is what the function is called for me, and this executes a try to get a response form the api endpoint, the requests grabs the endpoint and applies the parameters of the access_key which in this case is the api key that I got from the website earlier. After this the data is set to response.json and if this response is good the data clears and goes to the next step which is an if statement to see if exchange_rates = data['rates']. This is more of an authentication check to make sure all data so far is valid and good before continuing on, after this I set up a sorted exchange rate function that will sort the data that I get from the API, this is because otherwise the data comes out looking blocky and not very well put together. format is also set so that the display is currency code, followed by the currency code and then exchange rate followed by the rate. This is then sorted throough a for, which state that for currency and rate in sorted_exchange.items() to sort it according to alphabetical order. This is then followed by a render template that has my styling and the exchange_rates=format to ensure that prior formatting in the app.py file is also included and gives us a black background, sleek look at the API data. There isn't much functionality on the user side but it does show all of the data in alphabetical order which will help with searching for data on specific codes easier.

As for the exchange_rates.html this is a simple file, it styles the data that the API ends, with the main bulk being a for loop that goes over each part of the output API, this makes sure that each item is set to the exchange_rate part and that it is set where it is, in this case alphabetically. The div is just to set the class for exchange-rate here as well. The next two lines are just styling and setting the currency code and exchange rate the same, applying a line break after each and then displaying the value that is assigned to that part specifically. This gies us the sleek output that is shown in the code

Overall, this was all that was changed for this assignment. It was a fun assignment and taught me about APIs which is dope. Definitely will try to work on making an adjustment so that there is more user interaction within the API and not just data given
The closest thing that I have for that is a search function which makes the currency code equal to arguments and returns the data on this based on what a user enters in the url. This also utilizes the same types of functions to work, however the way that it works is pretty unintuitive and the normal person will not know how to fetch any data. The reason being that you have to set up the url as /search?currency_code= and then enter the three code that you want to see the rates for. It works but can definitely be improved later on to provide the most optimal experience.

This final project was quite the undertaking, the main improvements are the additions of a gif to the dashboard which is pretty basic, and a forum post feature that took several hours to complete. The libraries required were flask login, restful, sql alchemy, werkzeug and requests. wtfforms was not really utilized at all but it could be an alternative method. Here what I used was the db.model to attach the post and reply functions of my forum so that the data can be securely stored. To do this I did the same thing that I did for the User class but changed up variable types to match the fields for the id, content and post id, making the foreign key for replies the post id so that the replies knows exactly what comment they are replying to. This was followed by creating the routes which included forum_post which has Get and Post functions and /reply/<int:post_id> which has the same things. The first one starts by defning what a forum post is, it clarifies that if the request method is to post then new cotent should be being posted in every case, this is followed by adding said post to a db.session so that it is stored in the database for use even after the app has stopped running. After this there is a url for display post that shows if a post was successfully posted or not. At the end what is returned is a post.html which is the main forum page and shows every single post and reply in order. posts are queried so this effect can take place. Reply does the same thing for the most part, however it has to check if the content it is replying to exists, this is why if the id for the post is invalid it will return a 404 error instead. The reply_content will be accessed through a request form that has the parameters of reply content. New replies are replies that have content from user inputs that are posted within the reply box. db session works for this as well by making a new session and committing the content. This also sends users back to the user post page where they can see their post or a 404 error if there is an issue.

The next step was the display post page which essentially just works to show that the responses are being recorded properly and going through, this was made with a simple route that works from the post_id of the post or reply and returns the post from the query or a 404 error, it is effective testing.

The next step is the html files for these pages. The post html takes form action and sends it to the forum_post url, meaning that everything that is defined there will be getting this data and transforming it into data that the users can see in real time, the method it does this with is post, placeholder text is self explanatory and the button type is submit to confirm the data input. Then there is a % loop that goes over each post within the posts that were created and handles them in order, the div class is made to hold the posts and replies, so that I could add borders around them to make it clear which posts replies were referring to in a neat manner. Post content is just the content of the post the user types in, its held jere. The url for reply to post is just put there so that users have a easier time of replying to their posts if they have extra comments or for other people who may want to engage in banter. for reply in post.replies this goes over replies instead and lists them in order for their comment they are replying to, its easy to place them because they already have the post id baked into their contents.

The reply html works basically the same way so no real reason to go over it. There are hrefs here to go back to the main forum posts. The display post html is also similar, it just posts the content of posts and replies, if there are no replies it will tell you that there are no replies yet.

I also used git for version control, just figuring out how to use it properly in Vscode took several hours but I am glad that I learned it a bit, its very interesting and gives pretty good benefits even if I dont fully understand it yet, this was probably the trickiest thing to work around in the project, all things considered.

Some difficulties with the project are the fact that the post feature needs to be more developed. It needs to have a date system that shows date and time and it needs to be able to tie messages to users so that other people know who they are replying to. Despite this I still feel the project was a success as those are minor issues that can be ironed out with little bits of code.

